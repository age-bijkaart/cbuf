<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: cbuf-test.es7</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: cbuf-test.es7</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>#!/usr/bin/env node

/** @file Test program for the &lt;a href="../index.html">cbuf&lt;/a> 
 * (circular buffer) module.
 */
'use strict';

/* Invariant and pre/post conditions for operations on circular buffer */

import { assert, assertx, nerrors} from './assert-test.js';
import CBUF from './cbuf.js';

/** Interval(from, size, n): generates the indices in the DATA array of a
 * circular buffer that
 * &lt;ul>
 * &lt;li> has '&lt;code>from&lt;/code>' as the index of the first element
 * &lt;li> and that contains '&lt;code>size&lt;/code>' elements out of
 * &lt;li> and has an underlying array of size '&lt;code>n&lt;/code>'
 * &lt;/ul>
 * E.g. for n = 3, from = 2, size = 2, we'll obtain [ 2, 0 ].
 * consisting of 'buf[2] buf[0]' represented by the interval [2..1[.
 *
 * The result is obtained as follows:
 * &lt;blockquote>
 *   &lt;code>
 *   [2 .. (2 + size)[ =  [2 .. 4 [
 *   &lt;/code>
 *   &lt;br/>
 *   &lt;code>
 *     =>  mod (n == 3) => [2 ..  1 [
 *   &lt;/code>
 * &lt;/blockquote>
 * The precondition is
 * &lt;blockquote>
 * &lt;code>from >= 0 &amp;&amp; n > 0 &amp;&amp;  0 >= size &lt; n&lt;/code>.
 * &lt;/blockquote>
 *
 * @param {Integer} from starting index
 * @param {Integer} size number of elements in the buffer
 * @param {Integer} n maximal size of the (array underlying the) buffer
 * @return {Array} [from % n .. (from+size)%n [
 */
let interval = 
  (from, size, n) => 
    Array.from(Array(from + size).keys())
      /*eslint no-unused-vars: ["error", { "argsIgnorePattern": "^_" }]*/
      .filter((el, i, _) => from &lt;= i)
      .map((el) => (el % n));
	
	
/** @param {CircularBuffer} cbuf
 * @returns {Integer} &lt;code>cbuf[CBUF.BEGIN]&lt;/code>
 */
const begin = (cbuf) => cbuf[CBUF.BEGIN];

/** @param {CircularBuffer} cbuf
 * @returns {Integer} &lt;code>cbuf[CBUF.POP]&lt;/code>
 */
const pop = (cbuf) => cbuf[CBUF.POP];

/** @param {CircularBuffer} cbuf
 * @returns {Array} &lt;code>cbuf[CBUF.DATA]&lt;/code>
 */
const data = (cbuf) => cbuf[CBUF.DATA];
/** @param {CircularBuffer} cbuf
 * @returns {Integer} &lt;code>cbuf[CBUF.DATA].length&lt;/code>
 */
const length = (cbuf) => data(cbuf).length;
/** @param {CircularBuffer} cbuf
 * @returns {Any} &lt;code>CBUF.last(cbuf)]&lt;/code>
 */
const last = (cbuf) => CBUF.last(cbuf);


/** Size of unoccupied part of &lt;code>cbuf[CBUF.DATA]&lt;/code.
 * @param {CircularBuffer} cbuf
 * @returns {Integer} &lt;code>cbuf[CBUF.DATA].length - cbuf{CBUF.POP]&lt;/code>
 */
const freesz = (cbuf) => length(cbuf) - pop(cbuf);

/** The contents of a circular buffer is an array of elements, starting with
 * the oldest (FIFO, &lt;code>CBUF.shift&lt;/code> will return the starting element)
 * and ending with the most recently added.
 * This corresponds to the FIFO operations on the buffer: 
 * &lt;code>CBUF.push&lt;/code> will append at the end while &lt;code>CBUF.shift&lt;/code>
 * will remove from the front.
 * This function will return this contents as an array of elements in FIFO
 * order.
 * @param {CircularBuffer} cbuf
 * @return {Array} array of elements in circular buffer, from oldest to
 * youngest 
 */
const contents = (cbuf) => interval(begin(cbuf), pop(cbuf), length(cbuf))
                          .map((i) => data(cbuf)[i]); 

/* Rest of circular buffer, i.e. list of cbuf[DATA] elements that are not
 * part of the circular buffer.
 * @param {CircularBuffer} cbuf
 * @return {Array} array of non-elements, i.e. 
 * &lt;code>cbuf[CBUF.DATA][i]&lt;/code> where i is not an index 'in use'
 * If all is well, this should be an array of 'undefined'.
 */
const rest = (cbuf) => interval(begin(cbuf) + pop(cbuf), freesz(cbuf), length(cbuf))
                      .map((i) => data(cbuf)[i]); 
	
/** Circular buffer invariant.
 * @param {CircularBuffer} cbuf 
 * @returns {Boolean} true iff the invariant holds on &lt;code>cbuf&lt;/code>
 */
const invariant = (cbuf) => {
  return true &amp;&amp; // silly JS thinks return by itself ends the statement
      length(cbuf) > 0
    &amp;&amp; 
      ( pop(cbuf) >= 0 &amp;&amp; pop(cbuf) &lt;= length(cbuf) ) 
    &amp;&amp; 
      ( begin(cbuf) >= 0 &amp;&amp; begin(cbuf) &lt; length(cbuf) )
    &amp;&amp; 
      contents(cbuf).every((x)=> x !== undefined)
    &amp;&amp; 
      rest(cbuf).every((x)=> x === undefined)
  ;
}

/** Shallow comparison of arrays, maybe it's built in but I couldn't find it 
 * @param {Array} a1 to be compared with &lt;code>a2&lt;/code>
 * @param {Array} a2 to be compared with &lt;code>a1&lt;/code>
 * @returns {Boolean} true iff arrays have the same size and identical
 * elements. */
const array_eq = (a1, a2) => 
  (a1.length !== a2.length ? false : a1.every((x, i) => x === a2[i]));

/**  Version of the standard
 * &lt;a
 * href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/push">
 * Array.push&lt;/a> that returns a copy of the array with the element appended
 * @param {Array} a array on a copy of which an element will be pushed
 * @param {Any} x element to be appended (pushed) to array
 * @returns {Array} copy of &lt;code>a&lt;/code> with &lt;code>x&lt;/code> appended
 */
const array_push = (a, x) => {
  let b = Array.from(a); b.push(x); return b;
}

/** Specification (contract) of push operation 
 * Essentially, the specification says that 
 * &lt;ul>
 * &lt;li>either orig is full and then
 *
 *   &lt;code>
 *   contents(next) == contents(orig)
 *   &lt;/code>
 *
 * &lt;li>or
 *
 *   &lt;code>
 *   contents(next) == array_push(contents(orig), x)
 *   &lt;/code>
 * &lt;/ul>
 * Of course, the invariant must be true before and after the operation.
 * @see {@link array_push}
 * @param {CircularBuffer} orig circular buffer before the push
 * @param {Any} x element to be pushed, must be defined
 * @param {CircularBuffer} next circular buffer after push
 * @returns {Boolean} true iff the contract is satisfied
 */
const cbuf_push_contract = (orig, x, next) => 
  (
      invariant(orig)
    &amp;&amp; 
      invariant(next) 
    &amp;&amp; 
      (
        ( 
            array_eq(array_push(contents(orig), x), contents(next))
          &amp;&amp;
            last(next) === x 
        ) 
      || 
        ( 
            CBUF.full(orig) 
          &amp;&amp; 
            array_eq(contents(orig), contents(next)) 
        )
      )
  );

/** Execute the push operation and check that its contract is satisfied 
 * The contract is checked by {@link assert}.
 * @param {CircularBuffer} cbuf circular buffer on which an element will be
 * pushed
 * @param {Any} x element to be pushed, must not be &lt;code>undefined&lt;/code>.
 * @param {Boolean} result of the push operation
 * @returns {Boolean} true iff &lt;code>CBUF.push(cbuf, x)&lt;/code> succeeded
 * @see &lt;a href="../global.html#cbuf_push">cbuf_push&lt;/a>
 */
const checked_cbuf_push = (cbuf, x) => {
  const orig = CBUF.clone(cbuf);
  const ok = CBUF.push(cbuf, x);
  assert(cbuf_push_contract(orig, x, cbuf),
      `check_cbuf_push contract CBUF.push(${CBUF.tostring(orig)}, ${x}) holds`,
      `check_cbuf_push contract CBUF.push(${CBUF.tostring(orig)}, ${x}) fails`
      );
  return ok;
};



/** Specification (contract) of the 'shift' operation.
 * Essentially, the specification says that:
 * &lt;ul>
 * &lt;li> either orig is empty:
 *   &lt;code>x === undefined &amp;&amp; next === orig&lt;/code>
 * &lt;li> or
 *   &lt;code>contents(orig) == x ++ contents(next)&lt;/code>
 *   where '++' means ``append''
 * &lt;/ul>
 * Naturally, both &lt;code>orig&lt;/code> and &lt;code>next&lt;/code> should satisfy the
 * invariant.
 * @param {CircularBuffer} orig buffer before shift operation
 * @param {Any} x return of &lt;code>cbuf_shift(orig)&lt;/code>
 * @param {CircularBuffer} next buffer after shift operation
 * @returns {Boolean} true iff the contract is satisfied
 */
const cbuf_shift_contract = (orig, x, next) =>
  (
      invariant(orig)
    &amp;&amp; 
      invariant(next)
    &amp;&amp; 
      (
        (
            pop(orig) === 0 
          &amp;&amp; 
            array_eq(contents(next), contents(orig)) 
          &amp;&amp; 
            x === undefined
        )
      || 
        (
            array_eq(contents(orig).slice(1), contents(next))
          &amp;&amp; 
            array_eq([x], contents(orig).slice(0, 1))
        )
    )
  );

/** Execute the shift operation and check that its contract is satisfied.
 * If the contract is not satisfied, the errors is noted using {@link assert}
 * @param {CircularBuffer} orig buffer before shift operation
 * @returns {Any} the first element of &lt;code>orig&lt;/code> or
 * &lt;code>undefined&lt;/code> if the latter is empty.
 * @see &lt;a href="../global.html#cbuf_shift">cbuf_shift&lt;/a>
 */
const checked_cbuf_shift = (cbuf) => { 
  const orig = CBUF.clone(cbuf); 
  const x = CBUF.shift(cbuf); 
  assert(cbuf_shift_contract(orig, x, cbuf),
      `check_cbuf_shift contract ${x} = CBUF.shift(${orig}) holds`,
      `check_cbuf_shift contract ${x} = CBUF.shift(${orig}) fails`
      );
  return x; 
};

/**
 * Function that checks &lt;code>CBUF.iterable&lt;/code> by verifying that 
 * the result of appending elements from a 
 *
 * &lt;code>for ..  of&lt;/code>
 *
 * loop equals &lt;code>contents(cbuf).
 * If the test failed, it will be noted using {@link assert}
 * @param {CircularBuffer} cbuf to be checked
 * @returns {Boolean} true iff the test succeeded
 */
function check_iterable(cbuf) {
  console.log('checking iterable on current circular buffer: ',
      CBUF.tostring(cbuf));
  {
    let seqit = [];
    for (const z of CBUF.iterable(cbuf)) {
      seqit.push(z);
    }
    let eql = array_eq(seqit, contents(cbuf));
    assert(eql,
      `Iterable yields ${seqit}, i.e. the contents ${contents(cbuf)}`,
      `Iterable unexpectedly yields ${seqit}, not the contents ${contents(cbuf)}`
      );
    return eql;
  }
}

/** 
 * Check that scanning &lt;code>cbuf&lt;/code> in a traditional way from
 * cbuf[CBUF.DATA][cbuf[CBUF.BEGIN]] onwards yields
 * &lt;code>contents(cbuf)&lt;/code>.
 * If the test failed, it will be noted using {@link assert}
 * @param {CircularBuffer} cbuf to be checked
 * @returns {Boolean} true iff the test succeeded
 */
function check_ordered_access(cbuf) { 
  let buffer = []
  let p = 0;
  while (p &lt; cbuf[CBUF.POP]) {
    buffer.push(
        cbuf[CBUF.DATA][(cbuf[CBUF.BEGIN] + p++) % (cbuf[CBUF.DATA].length)]
        );
  }

  let eql= array_eq(buffer, contents(cbuf));
  assert(eql,
    `Loop yields ${buffer} which equals the contents ${contents(cbuf)}`,
    `Loop unexpectedly yields ${buffer}, not the contents ${contents(cbuf)}`
    );
  return eql;
}

/** Main test function */
try { 
  console.log('Start cbuf test');
  /* in the comments, we use 'und' to abbreviate 'undefined' */
  let cbuf = CBUF.create(5);
  console.log('cbuf_create(5) => ', CBUF.tostring(cbuf));
  assert(invariant(cbuf),
      'New CBUF.create(5) satisfies invariant',
      'New CBUF.create(5) violates invariant!'
      );

  assert(( CBUF.last(cbuf) === undefined ), 
      'CBUF.last of empty buf is undefined',
      `CBUF.last of empty, '${CBUF.last(cbuf)}' not undefined as it should be`
      );

  /* [ und und und und und ], begin = 0, end = 0, pop = 0 */

	console.log("checked_cbuf_push(cbuf, 'a') = ", checked_cbuf_push(cbuf, 'a'));

  /* [ a und und und und ], begin = 0, end = 2, pop = 1 */

	console.log("checked_cbuf_push(cbuf, 'b') = ", checked_cbuf_push(cbuf, 'b'));

  /* [  a b und und und ], begin = 0, end = 2, pop = 2 */

	console.log("checked_cbuf_push(cbuf, 'c') = ", checked_cbuf_push(cbuf, 'c'));

  /* [  a b c und und ], begin = 0, end = 3, pop = 3 */

	console.log("checked_cbuf_push(cbuf, 'd') = ", checked_cbuf_push(cbuf, 'd'));

  /* [  a b c d und ], begin = 0, end = 4, pop = 4 */

	console.log("checked_cbuf_push(cbuf, 'e') = ", checked_cbuf_push(cbuf, 'e'));

  /* [  a b c d e ], begin = 0, end = 0, pop = 5 (full) */

	console.log("checked_cbuf_push(cbuf, 'f') = ", checked_cbuf_push(cbuf, 'f'));

  /* [  a b c d e ], begin = 0, end = 0, pop = 5 (full) */

	console.log('checked_cbuf_shift(cbuf) = ', checked_cbuf_shift(cbuf));

  /* [ und b c d e ], begin = 1, end = 0, pop = 4 */

  check_ordered_access(cbuf);
  check_iterable(cbuf);

	console.log('checked_cbuf_shift(cbuf) = ', checked_cbuf_shift(cbuf));

  /* [ und und c d e ], begin = 2, end = 0, pop = 3 */

	console.log('checked_cbuf_shift(cbuf) = ', checked_cbuf_shift(cbuf));

  /* [ und und und d e ], begin = 3, end = 0, pop = 2 */

	console.log('checked_cbuf_shift(cbuf) = ', checked_cbuf_shift(cbuf));

  /* [ und und und und e ], begin = 4, end = 0, pop = 1 */
  check_ordered_access(cbuf);
  check_iterable(cbuf);

	console.log('checked_cbuf_shift(cbuf) = ', checked_cbuf_shift(cbuf));

  /* [ und und und und und ], begin = 0, end = 0, pop = 0  (empty) */
  check_ordered_access(cbuf);
  check_iterable(cbuf);

	console.log('checked_cbuf_shift(cbuf) = ', checked_cbuf_shift(cbuf));

  /* [ und und und und und ], begin = 0, end = 0, pop = 0  (empty) */

	console.log("checked_cbuf_push(cbuf, 'b') = ", checked_cbuf_push(cbuf, 'b'));

  /* [ b und und und und ], begin = 0, end = 1, pop = 1 */

	console.log("checked_cbuf_push(cbuf, 'c') = ", checked_cbuf_push(cbuf, 'c'));

  /* [ b c und und und ], begin = 0, end = 2, pop = 2 */

	console.log("checked_cbuf_push(cbuf, 'd') = ", checked_cbuf_push(cbuf, 'd'));

  /* [ b c d und und ], begin = 0, end = 3, pop = 3 */

	console.log("checked_cbuf_push(cbuf, 'e') = ", checked_cbuf_push(cbuf, 'e'));

  /* [ b c d e und ], begin = 0, end = 4, pop = 4 */

	console.log("checked_cbuf_push(cbuf, 'b') = ", checked_cbuf_push(cbuf, 'b'));

  /* [ b c d e b ], begin = 0, end = 0, pop = 5 (full) */

	console.log("checked_cbuf_push(cbuf, 'c') = ", checked_cbuf_push(cbuf, 'c'));
  /* [ b c d e b ], begin = 0, end = 0, pop = 5 (full) */
	console.log("checked_cbuf_push(cbuf, 'd') = ", checked_cbuf_push(cbuf, 'd'));
  /* [ b c d e b ], begin = 0, end = 0, pop = 5 (full) */
	console.log("checked_cbuf_push(cbuf, 'e') = ", checked_cbuf_push(cbuf, 'e'));
  /* [ b c d e b ], begin = 0, end = 0, pop = 5 (full) */
  check_ordered_access(cbuf);
  check_iterable(cbuf);

	console.log("checked_cbuf_shift(cbuf') = ", checked_cbuf_shift(cbuf));
  /* [ und c d e b ], begin = 1, end = 0, pop = 4  */
  check_ordered_access(cbuf);
  check_iterable(cbuf);
  /*eslint-disable no-process-exit*/
  process.exit(nerrors());
}
catch (e) {
  console.error(`${e.name}: ${e.message}`);
  process.exit(1);
}

</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#array_eq">array_eq</a></li><li><a href="global.html#array_push">array_push</a></li><li><a href="global.html#assert">assert</a></li><li><a href="global.html#assertx">assertx</a></li><li><a href="global.html#begin">begin</a></li><li><a href="global.html#cbuf_push_contract">cbuf_push_contract</a></li><li><a href="global.html#cbuf_shift_contract">cbuf_shift_contract</a></li><li><a href="global.html#check_iterable">check_iterable</a></li><li><a href="global.html#check_ordered_access">check_ordered_access</a></li><li><a href="global.html#checked_cbuf_push">checked_cbuf_push</a></li><li><a href="global.html#checked_cbuf_shift">checked_cbuf_shift</a></li><li><a href="global.html#contents">contents</a></li><li><a href="global.html#data">data</a></li><li><a href="global.html#error">error</a></li><li><a href="global.html#errors">errors</a></li><li><a href="global.html#freesz">freesz</a></li><li><a href="global.html#interval">interval</a></li><li><a href="global.html#invariant">invariant</a></li><li><a href="global.html#last">last</a></li><li><a href="global.html#length">length</a></li><li><a href="global.html#nerrors">nerrors</a></li><li><a href="global.html#pop">pop</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Sun Oct 29 2017 14:52:09 GMT+0100 (CET)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
