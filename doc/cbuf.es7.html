<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: cbuf.es7</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: cbuf.es7</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict';

/** Name for the property in a circular buffer object that refers to the array
 * containing the elements present in the circular
 * buffer. An 'empty' index in the array contains &lt;b>undefined&lt;/b>
 * @example
 *  import CBUF from 'cbuf';
 *  let c = cbuf_create(10);
 *  console.log(c[CBUF.DATA][0]); // print '&lt;b>undefined&lt;/b>'
 */
const DATA = Symbol('data');

/** Property name for the 'population' property in a circular buffer object.
 * The property contains the number of elements currently available in the
 * circular buffer.
 * @example
 *  import CBUF from 'cbuf';
 *  let c = cbuf_create(10);
 *  console.log(c[CBUF.POP]); // print 10
 */
const POP = Symbol('pop');

/** Name for the property in a circular buffer object that refers to the index
 * in the DATA array of the first (oldest) element of the circular buffer,
 * if this buffer is not empty (POP > 0). 
 * @example
 *  import CBUF from 'cbuf';
 *  let c = cbuf_create(10);
 *  CBUF.push(c, 'something');
 *  console.log(c[CBUF.BEGIN]); // print 'something';
 */
const BEGIN = Symbol('begin');

/** Create a new circular buffer (FIFO queue) with a fixed &lt;b>capacity&lt;/b>.
 * At no point can the circular buffer contain more than &lt;b>capacity&lt;/b>
 * elements.
 * &lt;br/>
 * Although not available as a direct property of the buffer -- the only
 * such properties are [DATA]{@link DATA}, [POP]{@link POP} and 
 * [BEGIN]{@link BEGIN} --
 * it can easily be accessed using the expression 
 * &lt;code>c[CBUF.DATA].length&lt;/code> where &lt;code>c&lt;/code> is the
 * circular buffer.
 * &lt;br/>
 * The function also [seals]{@link
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/seal}
 * the DATA array, so it cannot be extended.
 *
 * @param {integer} capacity the size of the DATA array, i.e.
 * the maximal capacity. Must be strictly positive, obviously 
 * (but this is not verified by the implementation).
 *
 * @returns {CircularBuffer} A newly created empty circular buffer with a
 *  capacity equal to the parameter
 *
 * @example
 *  import CBUF from 'cbuf';
 *  let c = cbuf_create(10);
 *  // postcondition: 
 *  assert( c[CBUF.POP] === 0 &amp;&amp; c[CBUF.BEGIN] === 0 &amp;&amp; 
 *    c[CBUF.DATA].length === capacity &amp;&amp;
 *    foreach 0 &lt;= i &lt; c[CBUF.DATA].length : c[CBUF.DATA][i] === undefined
 *    );
 */
function cbuf_create(capacity) { 
  // Creates data as a array of size 'capacity' filled with '&lt;b>undefined&lt;/b>' values
  // See
  // https://stackoverflow.com/questions/28416547/difference-between-array-applynull-arrayx-and-arrayx
  // 
  // const data = Array.apply(null, {length: capacity});
  // The above line can be rewritten as:
  const data = [ ... {length: capacity} ];
  /** Makes cbuf[DATA] fixed length. */
  Object.seal(data);
  return ({[POP]: 0, [BEGIN]: 0, [DATA]: data});
}

/** Clone a circular buffer.
 * Note that the result is not a 'deep' copy, the DATA
 * array is cloned using [slice]{@link
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice}.
 * &lt;br/>
 * Note that cloning a 'subclass', i.e. a circular buffer with extra data
 * properties, will usually work using CBUF.clone but this should be verified.
 * E.g. an extra array data property will need extra code to clone its
 * contents.
 *
 * @param {CircularBuffer} cbuf  a valid circular buffer.
 *
 * @returns {CircularBuffer} A shallow clone of the argument. 
 *
 * @example
 *  import CBUF from 'cbuf';
 *  let c = cbuf_create(10);
 *  ... // do stuff with c
 *  let cc = CBUF.clone(c);
 *  assert(
 *    cc[CBUF.POP] === c[CBUF.POP] &amp;&amp; 
 *    cc[CBUF.BEGIN] === c[CBUF.BEGIN] &amp;&amp; 
 *    cc[CBUF.DATA] !== c[CBUF.DATA]) &amp;&amp;
 *    c[CBUF.DATA].foreach(c[CBUF.DATA][i] === cc[CBUF.DATA][i])
 *    );
 *  // the last line above shows it's a 'shallow' copy
 */
function cbuf_clone(cbuf) { 
  /** First copy all properties: POP, BEGIN, DATA */
  let clone = Object.assign({}, cbuf); 
  /** Next replace DATA with a new array that is a copy of the original one */
  clone[DATA] = Array.slice(cbuf[DATA]); 
  return clone; 
}

/** Check whether a circular buffer is empty
 *
 * @param {CircularBuffer} cbuf a valid circular buffer
 *
 * @returns {Boolean} true iff &lt;code>cbuf[CBUF.POP] === 0&lt;/code>
 *
 * @example
 *  import CBUF from 'cbuf';
 *  let c = cbuf_create(10);
 *  ... // do stuff with c
 *  if (CBUF.empty(c))
 *    assert(c[CBUF.DATA].forEach(c[CBUF.DATA][i] === undefined));
 */
const cbuf_empty = (cbuf) => ( cbuf[POP] === 0); 

/** Check whether a circular buffer is full, i.e. whether it is impossible
 * to append more elements to it.
 *
 * @param {CircularBuffer} cbuf a valid circular buffer
 *
 * @returns {Boolean} true iff  
 *  &lt;code>cbuf[CBUF.POP] === cbuf[CBUF.DATA].length&lt;/code>
 *
 * @example
 *  import CBUF from 'cbuf';
 *  let c = cbuf_create(10);
 *  ... // do stuff with c
 *  // make room by removing the oldest element, if it is not 'in use', e.g. by
 *  // a cursor pointing into it
 *  if ( CBUF.full(c) ) {
 *    let el = c[CBUF.DATA][CBUF.BEGIN]; // oldest element
 *    if (el_is_not_refered_to)
 *      CBUF.shift(c);
 *  }
 */
const cbuf_full = (cbuf) => (cbuf[POP] === cbuf[DATA].length);
	
/** Retrieve the last element (most recently added in [FIFO]{@link
 * https://en.wikipedia.org/wiki/FIFO_(computing_and_electronics)} terms)
 * from the circular buffer. 
 * If the buffer is empty, &lt;b>undefined&lt;/b> is returned.
 * &lt;br/>
 * If the buffer is not empty, the index of the last element in DATA is
 * &lt;blockquote>
 * &lt;code>
 *  cbuf[DATA][(cbuf[BEGIN] + cbuf[POP] - 1) % cbuf[DATA].length]);
 * &lt;/code>
 * &lt;/blockquote>
 *
 * @param {CircularBuffer} cbuf a valid circular buffer
 *
 * @returns {Object} the last element of the circular buffer 
 *  or &lt;b>undefined&lt;/b> if cbuf is empty 
 */
const cbuf_last = (cbuf) => (cbuf_empty(cbuf) ?
     undefined : cbuf[DATA][(cbuf[BEGIN] + cbuf[POP] - 1) % cbuf[DATA].length]);

/** Increment its second argument modulo cbuf[DATA].length. While this function
 * is used internally, it is also useful to
 * access elements of the &lt;b>DATA&lt;/b> array while ignoring the circular buffer
 * that lives in it. 
 *
 * @param {CircularBuffer} cbuf a valid circular buffer 
 *
 * @param {Integer} an integer from &lt;code>[0 .. cbuf[DATA].length[&lt;/code>
 *
 * @returns {Integer} the index following the parameter index
 *  &lt;code>i&lt;/code> in &lt;code>cbuf[DATA][i]&lt;/code>. 
 *  The return value &lt;code>r&lt;/code> also sits in
 *  &lt;code>[0 .. cbuf[DATA].length[&lt;/code>
 * @example
 *  import CBUF from 'cbuf';
 *  let c = cbuf_create(10);
 *  const n = c[CBUF.DATA].length - 1;
 *  const next = CBUF.inc(c, n) ;
 *  assert(next === 0);
 *  for (const i = 0; (i&lt;c[CBUF.DATA].length); ++i) {
 *    let r = CBUF.inc(c, i);
 *    assert(0 &lt;= r &amp;&amp; r &lt; c[CBUF.DATA].length);
 *  }
 */
const cbuf_inc = (cbuf, i) => (i + 1) % cbuf[DATA].length; 

/** Append a defined element to the end of the circular buffer. The operation
 * only succeeds if the circular buffer is not [full]{@link cbuf_full}.
 * The return value is a boolean indicating the success or failure of the 
 * append operation.
 *
 * @param {CircularBuffer} cbuf a valid circular buffer
 *
 * @param {Any} x a &lt;b>defined&lt;/b> object (the implementation checks this)
 *
 * @returns {Boolean} &lt;code>true&lt;/code> iff the operation succeeded,
 *  &lt;code>false&lt;/code> otherwise.
 *
 * @example
 *  import CBUF from 'cbuf';
 *  let c = cbuf_create(2);
 *  let x; 
 *  let y;
 *  let z;
 *  .. // do stuff with x, y and z
 *  assert(CBUF.push(cbuf,x));
 *  assert(CBUF.push(cbuf,y));
 *  assert(!CBUF.push(cbuf,z));
 *  assert(CBUF.full(cbuf));
 */
function cbuf_push(cbuf, x) { 
  if ( (x === undefined) || cbuf_full(cbuf) ) {
    return false; 
  }
  cbuf[DATA][(cbuf[BEGIN] + cbuf[POP]) % cbuf[DATA].length] = x; 
  ++(cbuf[POP]); 
  return true; 
}
	
/** Retrieve and remove the element at the front of the circular buffer (the
 * oldest one in * [FIFO]{@link
 * https://en.wikipedia.org/wiki/FIFO_(computing_and_electronics)}) terms).
 * If the operation fails, and this can only happen if the buffer is empty,
 * &lt;b>undefined&lt;/b> is returned.
 * &lt;br/>
 * If the operation succeeds and returns a defined object &lt;code>x&lt;/code> from 
 * index &lt;code>cbuf[DATA][BEGIN]&lt;/code>, the contents of &lt;code>x&lt;/code>'s 
 * index will be set
 * to &lt;b>undefined&lt;/b>. That way, the circular buffer will not be in the
 * way of a possible garbage collection of &lt;code>x&lt;/code>
 *
 * @param {CircularBuffer} cbuf a valid circular buffer
 *
 * @return {Any} the defined first element 
 *  &lt;code>(cbuf[CBUF.DATA][CBUF.BEGIN])&lt;/code> shifted out of cbuf 
 *  or &lt;b>undefined&lt;/b> if the buffer is [empty]{@link cbuf_empty}
 *
 * @example
 *  import CBUF from 'cbuf';
 *  let c = cbuf_create(2);
 *  let x; 
 *  let y;
 *  let z;
 *  .. // do stuff with x, y and z
 *  assert(CBUF.push(cbuf,x));
 *  assert(CBUF.push(cbuf,y));
 *  const u = CBUF.shift(cbuf);
 *  assert(u === x);
 *  assert(CBUF.push(cbuf,z));
 *  assert(CBUF.full(cbuf));
 *  assert(cbuf[CBUF.BEGIN] == 1); // not 0
 *  assert(cbuf[0] === z); // last element
 *  assert(CBUF.last(cbuf) === z);
 */
function cbuf_shift(cbuf) { 
  if ( cbuf_empty(cbuf) ) {
    return undefined; 
  }
  const x = cbuf[DATA][cbuf[BEGIN]]; 
  cbuf[DATA][cbuf[BEGIN]] = undefined; 
  cbuf[BEGIN] = cbuf_inc(cbuf, cbuf[BEGIN]); 
  --(cbuf[POP]); 
  return x; 
}

/** A generator function that supports retrieving all elements in the circular
 * buffer/FIFO queue in
 * order by repeated calling this function.
 *
 * @param {CircularBuffer} a valid circular buffer
 *
 * @returns {Iterable} an &lt;a
 * href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols">
 * iterable&lt;/a>
 *
 * @example
 *  import CBUF from 'cbuf';
 *  let c = cbuf_create(3);
 *  let x = { 'a', 'b', 'c', 'd' };
 *  assert(CBUF.push(cbuf,x[0])); // 'a'
 *  assert(CBUF.push(cbuf,x[1])); // 'b'
 *  assert(CBUF.push(cbuf,x[2])); // 'c'
 *  const u = CBUF.shift(cbuf); // => 'a'
 *  assert(u === x[0]);
 *  assert(CBUF.push(cbuf,x[3])); // 'd'
 *  assert(cbuf[CBUF.BEGIN] === 1);
 *  assert(cbuf[CBUF.POP] === 3);
 *  assert(CBUF.full(cbuf));
 *
 *  let q = [];
 *  for (const z of CBUF.iterable(cbuf)) 
 *    q.push(z);
 *  // q === [ 'b', 'c', 'd' ];
 *
 *  // alternative
 *  q = [];
 *  let p = 0;
 *    while (p &lt; cbuf[CBUF.POP])
 *      q.push(cbuf[CBUF.DATA][(CBUF.inc(cbuf, cbuf[CBUF.BEGIN] + p++)))
 *  // q === [ 'b', 'c', 'd' ];
 *
 */
function cbuf_iterable(cbuf) {
  // note the use of 'yield' indicating
  // that the function remembers where it was for the next call.
  let it = {};
  it[Symbol.iterator] = function* () {
    let i = cbuf[BEGIN];
    let pop = cbuf[POP];
    while ( pop > 0 ) {
      yield cbuf[DATA][i];
      i = cbuf_inc(cbuf, i);
      --pop;
    }
  }
  return it;
}

/** Make a human-readable string representation of a circular buffer.
 *
 * @param {CircularBuffer} cbuf a valid circular buffer
 *
 * @returns {String} a string representation of &lt;code>cbuf&lt;/code>
 *
 * @example
 * Example output:
 *
 *  '3 items in [1..0[: data = 
 *    0: '"d"'
 *    1: '"b"'
 *    2: '"c"'
 *    ]'
 */
function cbuf_tostring(cbuf) {
  let s = `CBUF ${cbuf[POP]} items in `
    + `[${cbuf[BEGIN]} .. ${(cbuf[BEGIN] + cbuf[POP]) % cbuf[DATA].length}[` 
    + ': data = [';
  cbuf[DATA].forEach(
      /*eslint no-unused-vars: ["error", { "argsIgnorePattern": "^_" }]*/
      (el, i, _) => ( s += `\n${i}: ${el ? JSON.stringify(el) : el}, ` )
      );
  s += '\n]';
  return s;
}

/** All functions/constants in this file are exported. Note that the naming
 * strategy is such that an 'internal' call
 * &lt;blockquote
 * &lt;code>
 * cbuf_push(c, x);
 * &lt;/code>
 * &lt;/blockquote>
 * becomes
 * &lt;blockquote
 * &lt;code>
 *    CBUF.push(c,x);
 * &lt;/code>
 * &lt;/blockquote>
 * which is not too far from a 'class based'
 * &lt;code>c.push(x)&lt;/code> 
 * where the
 * '&lt;code>this&lt;/code>' argument is always the first argument in the 
 * '&lt;code>CBUF.push(c, .. )&lt;/code> call. Except that the object is not called
 * '&lt;code>this&lt;/code>' and its binding is trivial, unlike that of 
 * '&lt;code>this&lt;/code>'.
 * &lt;/blockquote>
 * The above depends on an import statement such as
 * &lt;blockquote
 * &lt;code>
 * import CBUF from 'cbuf.js';
 * &lt;/code>
 * &lt;/blockquote>
 *
 * @exports CBUF
 */
module.exports = {
  POP: POP, BEGIN: BEGIN, DATA: DATA,
  create: cbuf_create, clone: cbuf_clone,
  empty: cbuf_empty, full: cbuf_full, last: cbuf_last, iterable: cbuf_iterable,
  push: cbuf_push, inc: cbuf_inc, shift: cbuf_shift,
  tostring: cbuf_tostring
};

</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-CBUF.html">CBUF</a></li></ul><h3>Global</h3><ul><li><a href="global.html#BEGIN">BEGIN</a></li><li><a href="global.html#cbuf_clone">cbuf_clone</a></li><li><a href="global.html#cbuf_create">cbuf_create</a></li><li><a href="global.html#cbuf_empty">cbuf_empty</a></li><li><a href="global.html#cbuf_full">cbuf_full</a></li><li><a href="global.html#cbuf_inc">cbuf_inc</a></li><li><a href="global.html#cbuf_iterable">cbuf_iterable</a></li><li><a href="global.html#cbuf_last">cbuf_last</a></li><li><a href="global.html#cbuf_push">cbuf_push</a></li><li><a href="global.html#cbuf_shift">cbuf_shift</a></li><li><a href="global.html#cbuf_tostring">cbuf_tostring</a></li><li><a href="global.html#DATA">DATA</a></li><li><a href="global.html#POP">POP</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Sun Oct 29 2017 14:51:58 GMT+0100 (CET)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
